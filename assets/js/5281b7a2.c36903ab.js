"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[927],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,m=d["".concat(l,".").concat(p)]||d[p]||u[p]||i;return n?a.createElement(m,r(r({ref:t},h),{},{components:n})):a.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1527:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:2},r="Architecture",s={unversionedId:"architecture",id:"architecture",title:"Architecture",description:"Components",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/website/docs/architecture",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Project Guidelines",permalink:"/website/docs/documentation"},next:{title:"Project Report",permalink:"/website/docs/report"}},l={},c=[{value:"Components",id:"components",level:2},{value:"OBUs and RSUs",id:"obus-and-rsus",level:3},{value:"The Messaging Network",id:"the-messaging-network",level:3},{value:"Orchestrator",id:"orchestrator",level:3},{value:"MECs",id:"mecs",level:3},{value:"Manager",id:"manager",level:3},{value:"Grafana Dashboards",id:"grafana-dashboards",level:3},{value:"Technologies",id:"technologies",level:2},{value:"Docker",id:"docker",level:3},{value:"Mosquitto",id:"mosquitto",level:3},{value:"Kubernetes",id:"kubernetes",level:3},{value:"Helm",id:"helm",level:3},{value:"Open Source MANO",id:"open-source-mano",level:3},{value:"Grafana",id:"grafana",level:3},{value:"FastAPI",id:"fastapi",level:3}],h={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"architecture"},"Architecture"),(0,o.kt)("h2",{id:"components"},"Components"),(0,o.kt)("p",null,"Our architecture has 6 main components: the VCUs (both the OBUs and RSUs), the messaging network, the orchestrator, the MECs, the manager and the Grafana dashboards. "),(0,o.kt)("h3",{id:"obus-and-rsus"},"OBUs and RSUs"),(0,o.kt)("p",null,"The OBUs and RSUs are the physical component that we are creating a DT for. They generate data continuously and publish it to a network of message brokers. "),(0,o.kt)("p",null,"For each of these objects we instantiate its corresponding digital twin, which gathers all the information regarding its object and forwards it to our user-interface. "),(0,o.kt)("h3",{id:"the-messaging-network"},"The Messaging Network"),(0,o.kt)("p",null,"The messages in the network are organized by topics, relating both to the sender\u2019s identity and geographic location, and each DT fetches their respective data from them. This includes both data related to its physical counterpart and the surrounding stations to enable cooperation. "),(0,o.kt)("h3",{id:"orchestrator"},"Orchestrator"),(0,o.kt)("p",null,"The orchestrator is the component that handles the lifecycle of the digital twins. It orchestrates their deployment and management and the resources needed to run these, like network connectivity and virtual machines.  "),(0,o.kt)("p",null,"It contains an instance of OSM and it is constantly running and available. We will not get into much detail on how OSM works, later in the report its functioning is explained more in-depth.  "),(0,o.kt)("p",null,"A brief simplification would be the OSM allows our solution to control the digital twins that are or must be deployed and instantiated while handling the related network and infrastructure aspects. Therefore, it is easy to understand how the orchestrator plays a key role in our solution. "),(0,o.kt)("h3",{id:"mecs"},"MECs"),(0,o.kt)("p",null,"The MEC nodes are the hosts for the DTs. These computing nodes are located at the edge of the network, thus allowing for the deployment and execution of the service closer to the devices. "),(0,o.kt)("p",null,"Due to the nature of a CNF, all stages of the DT\u2019s lifecycle take place in these nodes, from instantiation to deletion. The orchestrator communicates directly with the MECs when it needs to create or delete a digital twin.  "),(0,o.kt)("p",null,"In our solution, we only used 2 different MECs two implement and showcase the migration of a DT between both. In a real-world scenario, there would be dozens, in distinct locations and from different network communications operators. "),(0,o.kt)("h3",{id:"manager"},"Manager"),(0,o.kt)("p",null,"The manager can be considered the higher-level component of the system. It implements the migration process, is responsible for listening for migrating triggers and handling the subsequent migration logic, as well as supporting Grafana by providing some real-time data, such as the DT location in the system.  "),(0,o.kt)("p",null,"It is the manager who communicates directly with the Orchestrator and controls when a migration should occur or not. The trigger for a migration is based on the physical location of the OBU and it is automated. However, an API needs to be implemented, that provides a collection of endpoints that allow us to execute operations, such as starting a migration process on a DT, but also provides relevant information to the Data Visualization Dashboard. "),(0,o.kt)("h3",{id:"grafana-dashboards"},"Grafana Dashboards"),(0,o.kt)("p",null,"A Grafana instance is deployed on the same machine that the manager is on. This instance consumes the data from the message network and displays it in a user-friendly interface. "),(0,o.kt)("p",null,"Important to note a small but relevant component adjacent to Grafana which is the proxy, an intermediary in communications that transforms some of the values before sending them to Grafana. "),(0,o.kt)("br",null),(0,o.kt)("div",{style:{textAlign:"center"}},(0,o.kt)("img",{src:"https://media.discordapp.net/attachments/1077307423636869142/1112187119289516133/Screenshot_from_2023-05-28_02-15-02.png?width=1440&height=334",style:{maxWidth:"80%"}}),(0,o.kt)("p",null,"Image 1 - Component-Based Architecture")),(0,o.kt)("br",null),(0,o.kt)("h2",{id:"technologies"},"Technologies"),(0,o.kt)("p",null,"In this section, we describe the purposes and the reasons behind the choices of the technologies used to develop this project. Besides that, there is a brief preview of the advantages of using such technologies. "),(0,o.kt)("h3",{id:"docker"},"Docker"),(0,o.kt)("p",null,"Docker, the primary technology of our project, is the perfect choice to package our system due to its consistency, portability, and isolation. "),(0,o.kt)("p",null,"With Docker, it is possible to ensure that the system runs consistently across different environments and that it is possible to move between different hosts and environments easily. Besides that, Docker provides a prominent level of isolation, which helps to avoid conflicts and ensures that every environment has its unique system running separately from the others. "),(0,o.kt)("p",null,"Our Digital Twin consists of a docker image that runs in a container. "),(0,o.kt)("h3",{id:"mosquitto"},"Mosquitto"),(0,o.kt)("p",null,"Mosquitto is an open-source message broker that implements the MQTT protocol, popular among developers not only because of its lightweight and scalability but also for its cross-platform support and active community.  "),(0,o.kt)("p",null,"Since Mosquitto provides a library in C, we took advantage of it, making all communications between the different components of our architecture be handled by it. "),(0,o.kt)("h3",{id:"kubernetes"},"Kubernetes"),(0,o.kt)("p",null,"To manage, scale and deploy containerized applications, in this case, the digital twins, Kubernetes was the chosen technology for the job. Thanks to its high availability, portability and automatability. "),(0,o.kt)("p",null,"K8s is well known since it allows easy deployment across different environments and cloud providers and delivers a powerful and flexible API that allows you to automate many aspects of the management and deployment. All that helped save time and improve consistency. "),(0,o.kt)("p",null,"Using Kubernetes, we were able to create our Digital Twin application and deploy it in a cluster inside the different MECs. "),(0,o.kt)("h3",{id:"helm"},"Helm"),(0,o.kt)("p",null,"Helm is a package manager for Kubernetes which simplifies managing and deploying applications in Kubernetes. We can package an application by combining all files of the different application resources and combining them in a chart. This chart can then be shared and distributed. "),(0,o.kt)("p",null,"Helm also provides a command-line tool that allows users to execute operations on a chart, such as installing, upgrading, and deleting it from a Kubernetes cluster. "),(0,o.kt)("p",null,"We used Helm as a way of encapsulating our Kubernetes application in a way that our orchestrator (OSM) could handle.  "),(0,o.kt)("h3",{id:"open-source-mano"},"Open Source MANO"),(0,o.kt)("p",null,"Open Source MANO is an open-source project hosted by ETSI to develop an Open Source NFV Management and Orchestration software stack. It provides tools to develop, manage and straightforwardly orchestrate network functions, with benefits such as flexibility, scalability, and cost efficiency. It also provides a user-friendly dashboard to manage all these operations in an easier way.  "),(0,o.kt)("p",null,"OSM has gained popularity among the open-source community, with over 150 organizations contributing to its development. Not only that but its future looks promising, since Cloud-Native technology has seen a rise in popularity in the last few years, it is expected OSM to lead the way in the network management and orchestration world.  "),(0,o.kt)("p",null,"Using OSM, we were able to instantiate different CNFs and manage them. These CNFs used our Kubernetes application that was encapsulated in the Helm Chart we give OSM. "),(0,o.kt)("h3",{id:"grafana"},"Grafana"),(0,o.kt)("p",null,"Grafana was the chosen technology to take care of the visual component of this project. Its connectivity to the message broker is the main reason for this choice. Besides that, the data source integration, alerting features, and dashboard customization were other factors that led to this choice. "),(0,o.kt)("p",null,"Grafana supports integration with many different data sources, simplifying the monitoring of data coming from numerous sources in one place. It also provides a customizable interface, which can help analyse your data more effectively. "),(0,o.kt)("h3",{id:"fastapi"},"FastAPI"),(0,o.kt)("p",null,"FastAPI is a framework that allows for fast and simple API implementation. It provides us with the tools to create a python API in a fast, simple, and intuitive way while ensuring high performance and robustness.  "),(0,o.kt)("p",null,"It is famous among the developer community and used in many projects due to not only the advantages referred above but also due to its compliance with industry standards and automatic interactive documentation.  "),(0,o.kt)("p",null,"Since we needed a manager that could handle all the migration triggers and communicated them to our Orchestrator, we used FastAPI to develop an API that could handle these events."),(0,o.kt)("br",null),(0,o.kt)("div",{style:{textAlign:"center"}},(0,o.kt)("img",{src:"https://media.discordapp.net/attachments/1077307423636869142/1110486580789002332/arquitetura_updated.png",style:{maxWidth:"80%"}}),(0,o.kt)("p",null,"Image 2 - High-Level System Architecture")),(0,o.kt)("br",null),(0,o.kt)("p",null,"For more information, ",(0,o.kt)("a",{parentName:"p",href:"/website/docs/report"},"read")," the project specification report."))}u.isMDXComponent=!0}}]);